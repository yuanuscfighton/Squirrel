/*
  1. 函数之间兼容性比较复杂，需要考虑，
    （1）参数个数
    （2）参数类型
    （3）返回值类型

 */


/*
  2. 参数个数：参数多的兼容参数少的，（或者，参数少的可以赋值给多的）
    解释：在 js 中省略用不到的函数参数是很常见的，这样的使用方式，促成了 ts 中函数类型之间的兼容性
 */
type F11 = (a: number) => void
type F12 = (a: number, b: number) => void
let f11: F11
let f12: F12 = f11 // 参数少的可以赋值给多的


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*
  3. 参数类型
      相同位置的参数类型要相同（原始类型）或者兼容（对象类型）
 */
// 原始类型
type F21 = (a: number) => string
type F22 = (a: number) => string
let f21: F21
let f22: F22 = f21 // 函数类型 F22 兼容函数类型 F21，因为 F21 和 F22 的第1个参数类型相同

// 对象类型
interface Point2D {
    x: number;
    y: number
}

interface Point3D {
    x: number;
    y: number;
    z: number;
}

type F31 = (p: Point2D) => void
type F32 = (p: Point3D) => void
let f31: F31
let f32: F32 = f31


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*
  4. 返回值类型
      只关注返回值类型本身即可

    如果返回值类型是原始类型，此时两个类型都要相同，例如，类型 F41 和 F42
    如果返回值类型是对象类型，此时成员多的可以赋值给成员少的，例如，类型 F51 和 F52
 */
type F41 = () => string
type F42 = () => string
let f41: F41
let f42: F42 = f41

type F51 = () => { name: string }
type F52 = () => { name: string, age: number }
let f51: F51
let f52: F52
f51 = f52